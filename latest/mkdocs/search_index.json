{
    "docs": [
        {
            "location": "/", 
            "text": "jInv - A Flexible Flexible Julia Package for PDE Parameter Estimation\n\n\n\n\nBuild status\n\n\n \n \n\n\njInv\n is a flexible framework for solving PDE parameter estimation problems using Julia. Problems of this sort arise in various applications such as geophysical or medical imaging.  They are typically ill-posed and computationally challenging and developing robust and fast inversion algorithms is an active field of research. \njInv\n aims at advancing this field by providing efficient and easy-to-extend core functions commonly used for solving real-world problems.\n\n\n\n\nPackage Structure\n\n\nThe source code of \njInv\n is divided into five submodules:\n\n\n\n\nMesh\n - regular and tensor meshes in 2D and 3D as well as differential operators.\n\n\nLinearSolvers\n - interfaces to sparse and (if installed) direct linear solvers that can be used for solving the discretized PDEs.\n\n\nInverseSolve\n - methods commonly used in inverse problems such as misfit functions, regularization and numerical optimization.\n\n\nForwardShare\n - methods for solving forward problems in parallel.\n\n\nVis\n - visualization and plotting (requires \n)\n\n\nUtils\n - utility functions\n\n\n\n\n\n\nBasic Installation\n\n\nTo install \njInv\n start a Julia session and type in the REPL (we currently support Julia versions 0.5.x):\n\n\nINFO: Cloning jInv from https://github.com/JuliaInv/jInv.jl\njulia\n Pkg.clone(\nhttps://github.com/JuliaInv/jInv.jl\n,\njInv\n)\nERROR: jInv already exists\n\njulia\n Pkg.build(\njInv\n)\n\n\n\n\nThe above commands clone the latest version of \njInv\n and install the dependency \nKrylovMethods.jl\n, which provides iterative methods for solving (sparse) linear systems. Finally, some unit tests are run.\n\n\n\n\nOptional Packages for High-Performance\n\n\nFor better performance when solving parameter estimation problems with linear PDE constraints, \njInv\n automatically looks for high-end linear algebra packages. Currently, the following packages are supported:\n\n\n\n\nMUMPS.jl\n - wrapper for MUMPS. Used as a direct PDE solver\n\n\nParSpMatVec.jl\n - shared memory implementation for sparse matrix vector products\n\n\nPARDISO.jl\n - wrapper for PARDISO solver", 
            "title": "Home"
        }, 
        {
            "location": "/#jinv-a-flexible-flexible-julia-package-for-pde-parameter-estimation", 
            "text": "", 
            "title": "jInv - A Flexible Flexible Julia Package for PDE Parameter Estimation"
        }, 
        {
            "location": "/#build-status", 
            "text": "jInv  is a flexible framework for solving PDE parameter estimation problems using Julia. Problems of this sort arise in various applications such as geophysical or medical imaging.  They are typically ill-posed and computationally challenging and developing robust and fast inversion algorithms is an active field of research.  jInv  aims at advancing this field by providing efficient and easy-to-extend core functions commonly used for solving real-world problems.", 
            "title": "Build status"
        }, 
        {
            "location": "/#package-structure", 
            "text": "The source code of  jInv  is divided into five submodules:   Mesh  - regular and tensor meshes in 2D and 3D as well as differential operators.  LinearSolvers  - interfaces to sparse and (if installed) direct linear solvers that can be used for solving the discretized PDEs.  InverseSolve  - methods commonly used in inverse problems such as misfit functions, regularization and numerical optimization.  ForwardShare  - methods for solving forward problems in parallel.  Vis  - visualization and plotting (requires  )  Utils  - utility functions", 
            "title": "Package Structure"
        }, 
        {
            "location": "/#basic-installation", 
            "text": "To install  jInv  start a Julia session and type in the REPL (we currently support Julia versions 0.5.x):  INFO: Cloning jInv from https://github.com/JuliaInv/jInv.jl\njulia  Pkg.clone( https://github.com/JuliaInv/jInv.jl , jInv )\nERROR: jInv already exists\n\njulia  Pkg.build( jInv )  The above commands clone the latest version of  jInv  and install the dependency  KrylovMethods.jl , which provides iterative methods for solving (sparse) linear systems. Finally, some unit tests are run.", 
            "title": "Basic Installation"
        }, 
        {
            "location": "/#optional-packages-for-high-performance", 
            "text": "For better performance when solving parameter estimation problems with linear PDE constraints,  jInv  automatically looks for high-end linear algebra packages. Currently, the following packages are supported:   MUMPS.jl  - wrapper for MUMPS. Used as a direct PDE solver  ParSpMatVec.jl  - shared memory implementation for sparse matrix vector products  PARDISO.jl  - wrapper for PARDISO solver", 
            "title": "Optional Packages for High-Performance"
        }, 
        {
            "location": "/Mesh/", 
            "text": "jInv.Mesh\n\n\nDiscretization of differential operators is an essential ingredient of PDE parameter estimation problems. Depending on the problem and computational resources, different mesh types are needed in practical applications. The \nMesh\n submodule of \njInv\n provides different mesh geometry under the abstract type \nAbstractMesh\n. Currently, the \nMesh\n submodule methods and provides operators on regular and tensor meshes but is easily extensible.\n\n\n\n\nRegular Meshes\n\n\n\n\nList of types and methods\n\n\n#\n\n\njInv.Mesh.RegularMesh\n \n \nType\n.\n\n\ntype jInv.Mesh.RegularMesh \n: AbstractTensorMesh\n\nRegular mesh in 1D, 2D, and 3D\n\nFields:\n\n    domain::Vector{Float64}  - physical domain [min(x1) max(x1) min(x2) max(x2)]\n    h::Vector{Float64}       - cell size\n    x0::Vector{Float64}      - origin\n    dim::Int                 - dimension of mesh\n    n::Vector{Int64}         - number of cells in each dimension\n    nc::Int                  - total number of cells\n    nf::Vector{Int64}        - number of faces in each dimension\n    ne::Vector{Int64}        - number of edges in each dimension\n\n\n    Persistent Operators:\n\n    Operators should not be accessed directly. They will be built, if needed,\n    when accessing them using specified method. clear!(M) will release all \n    memory.\n\n        Div::SparseMatrixCSC    - divergence (faces -\n cell-centers)\n                                  Access via: getDivergenceMatrix(M)\n        Grad::SparseMatrixCSC   - gradient (nodal -\n edges)\n                                  Access via: getNodalGradientMatrix(M)\n        Curl::SparseMatrixCSC   - curl (edges -\n faces)\n                                  Access via: getCurlMatrix(M)\n        Af::SparseMatrixCSC     - face average (faces -\n cell-centers)\n                                  Access via: getFaceAverageMatrix(M)\n        Ae::SparseMatrixCSC     - edge average (edges -\n cell-centers)\n                                  Access via: getEdgeAverageMatrix(M)\n        An::SparseMatrixCSC     - nodal average (nodes -\n cell-centers)\n                                  Access via: getNodalAverageMatrix(M)\n        V::SparseMatrixCSC      - cell volumes (diagonal matrix)\n                                  Access via: getVolume(M)\n        F::SparseMatrixCSC      - face area (diagonal matrix)\n                                  Access via: getFaceArea(M)\n        L::SparseMatrixCSC      - edge length (diagonal matrix)\n                                  Access via: getLength(M)\n        Vi::SparseMatrixCSC     - inverse cell volumes (diagonal matrix)\n                                  Access via: getVolumeInv(M)\n        Fi::SparseMatrixCSC     - inverse face area (diagonal matrix)\n                                  Access via: getFaceAreaInv(M)\n        Li::SparseMatrixCSC     - inverse edge length (diagonal matrix)\n                                  Access via: getLengthAreaInv(M)\n        nLap::SparseMatrixCSC   - nodal Laplacian\n                                  Access via: getNodalLaplacian(M)\n\nExamples:\nM2D  = getRegularMesh([1.2 2.4 2.2 5.0],[3,4])  \nM3D  = getRegularMesh([1.2 2.4 2.2 5.0 0 1],[3,4,7])\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.TensorMesh3D\n \n \nType\n.\n\n\ntype jInv.Mesh.TensorMesh3D \n: AbstractTensorMesh\n\nFields:\n\n    h1::Vector{Float64}     - cell size in x1 direction\n    h2::Vector{Float64}     - cell size in x2 direction\n    h3::Vector{Float64}     - cell size in x3 direction\n    x0::Vector{Float64}     - origin\n    dim::Int                - dimension (dim=3)\n    n::Vector{Int64}        - number of cells in each direction\n    nc::Int                 - nc total number of cells (nc=prod(n))\n    nf::Vector{Int64}       - number of faces\n    ne::Vector{Int64}       - number of edges\n\nPersistent Operators:\n\nOperators should not be accessed directly. They will be built, if needed,\nwhen accessing them using specified method. clear!(M) will release all \nmemory.\n\n    Div::SparseMatrixCSC    - divergence (faces -\n cell-centers)\n                              Access via: getDivergenceMatrix(M)\n    Grad::SparseMatrixCSC   - gradient (nodal -\n edges)\n                              Access via: getNodalGradientMatrix(M)\n    Curl::SparseMatrixCSC   - curl (edges -\n faces)\n                              Access via: getCurlMatrix(M)\n    Af::SparseMatrixCSC     - face average (faces -\n cell-centers)\n                              Access via: getFaceAverageMatrix(M)\n    Ae::SparseMatrixCSC     - edge average (edges -\n cell-centers)\n                              Access via: getEdgeAverageMatrix(M)\n    An::SparseMatrixCSC     - nodal average (nodes -\n cell-centers)\n                              Access via: getNodalAverageMatrix(M)\n    V::SparseMatrixCSC      - cell volumes (diagonal matrix)\n                              Access via: getVolume(M)\n    F::SparseMatrixCSC      - face area (diagonal matrix)\n                              Access via: getFaceArea(M)\n    L::SparseMatrixCSC      - edge length (diagonal matrix)\n                              Access via: getLength(M)\n    Vi::SparseMatrixCSC     - inverse cell volumes (diagonal matrix)\n                              Access via: getVolumeInv(M)\n    Fi::SparseMatrixCSC     - inverse face area (diagonal matrix)\n                              Access via: getFaceAreaInv(M)\n    Li::SparseMatrixCSC     - inverse edge length (diagonal matrix)\n                              Access via: getLengthAreaInv(M)\n    nLap::SparseMatrixCSC   - nodal Laplacian\n                              Access via: getNodalLaplacian(M)\n\nExample: \n\nh1 = rand(4); h2 = rand(6); h3 = rand(5);\nM  = getTensorMesh2D(h1,h2,h3)\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getBoundaryNodes\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getBoundaryNodes(Mesh)\n\n\nReturns an array tuple (boundary node indices, inner node indices)\n\nInput: \n    Mesh::Abstract Mesh\n\nOutput:\n    Tuple{Array{Int64,1},Array{Int64,1}}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getEdgeAverageMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getEdgeAverageMatrix\n\n\nReturns Edge-to-CellCenter average matrix from Mesh.Ae. \nMatrix is constructed if Mesh.Ae is empty. \n\nFor 3D Mesh: Ae = [A1 A2 A3]\n\nInput: \n    Mesh::Abstract Mesh\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getEdgeIntegralOfPolygonalChain\n \n \nMethod\n.\n\n\n    function jInv.Mesh.getEdgeIntegralOfPolygonalChain\n\n    s = getEdgeIntegralPolygonalChain(mesh,polygon)\n    s = getEdgeIntegralPolygonalChain(mesh,polygon,normalize)\n\n    Compute the integral of a piecewise linear edge grid basis projected onto\n    the edges of a polygonal chain. This function can be used to evaluate the\n    source term of a line current carried by the polygonal chain in electromagnetic\n    modelling.\n\n    The piecewise linear edge grid basis consists of the functions\n      phix_i (i = 1 ... numXEdges)\n      phiy_i (i = 1 ... numYEdges)\n      phiz_i (i = 1 ... numZEdges)\n    where phix_i, phiy_i, phiz_i = 1 at the i-th x/y/z-directed edge\n      and phix_i, phiy_i, phiz_i = 0 at all other edges.\n\n    INPUT\n    mesh ...... Tensor mesh\n    polygon ... vertices of polygonal chain as numVertices x 3 array\n    normalize . divide line integral by length of integration path (boolean, optional)\n\n    OUTPUT\n    s ......... source vector\n\n    For a closed current loop, specify polygon such that\n    polygon[1,:] == polygon[end,:]\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getEdgeMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getEdgeMassMatrix(mesh,sigma)\n\nReturns mass matrix on cell edges, weighted by vector sigma.\nMatrix is always constructed. Uses pre-constructed edge averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getFaceAverageMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getFaceAverageMatrix\n\n\nReturns Face-to-CellCenter average matrix from Mesh.Af. \nMatrix is constructed if Mesh.Af is empty. \n\nFor 2D Mesh: Af = [A1 A2]\nFor 3D Mesh: Af = [A1 A2 A3]\n\nInput: \n    Mesh::Abstract Mesh\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getFaceMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getFaceMassMatrix(Mesh,sigma)\n\nReturns face mass matrix, weighted by vector sigma. \nMatrix is always constructed. Uses pre-constructed face averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getInterpolationMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getInterpolationMatrix\n\n\ncomputes bi/trilinear interpolation matrix P for cell-centered data from Mesh1 to Mesh2. If I1 is a cell-centerd discretization of some function  on Mesh1 then, its interpolant on Mesh2 is given by\n\n\nI2 = P*I1\n\n\nRequired Input:\n\n\nM1::AbstractTensorMesh \nM2::AbstractTensorMesh\n\n\n\n\nExample:\n\n\nIn mesh-decoupling, we use different meshes for the inverse solution\nand the different forward problems. \n\nMesh2Mesh = getInterpolationMatrix(Minv,Mfor)\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getNodalAverageMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getNodalAverageMatrix\n\n\nReturns Nodal-to-CellCenter average matrix from Mesh.An. \nMatrix is constructed if Mesh.An is empty. \n\nInput: \n    Mesh::Abstract Mesh\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getNodalMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getNodalMassMatrix(Mesh,sigma)\n\nReturns nodal mass matrix, weighted by vector sigma. \nMatrix is always constructed. Uses pre-constructed nodal averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getRegularMesh\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getRegularMesh\n\nConstructs regular mesh\n\nInput: \n    domain - physical domain rectangular\n    n      - number of cells in each dimension\n\nExamples:\nM2D  = getRegularMesh([1.2 2.4 2.2 5.0],[3,4])  \nM3D  = getRegularMesh([1.2 2.4 2.2 5.0 0 1],[3,4,7])\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getStraightLineCurrentIntegral\n \n \nMethod\n.\n\n\n    function jInv.Mesh.getStraightLineCurrentIntegral\n\n    [sx,sy,sz] = getStraightLineCurrentIntegral(hx,hy,hz,ax,ay,az,bx,by,bz)\n\n    Compute integral int(W . J dx^3) in brick of size hx x hy x hz\n    where W denotes the 12 local bilinear edge basis functions\n    and where J prescribes a unit line current\n    between points (ax,ay,az) and (bx,by,bz).\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getTensorMesh3D\n \n \nFunction\n.\n\n\nfunction jInv.Mesh.getTensorMesh3D\n\nconstructs TensorMesh3D\n\nRequired Input:\n\n   h1::Array - cell-sizes in x1 direction\n   h2::Array - cell-sizes in x2 direction\n   h3::Array - cell-sizes in x3 direction\n\nOptional Input\n   x0::Array - origin (default = zeros(3))\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getdEdgeMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getdEdgeMassMatrix(mesh,v)\n\nReturns derivative of edge mass matrix. Matrix is always \nconstructed. Uses pre-constructed edge averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getdFaceMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getdFaceMassMatrix(Mesh,v)\n\nReturns derivative of face mass matrix. Matrix is always \nconstructed. Uses pre-constructed face averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource\n\n\n#\n\n\njInv.Mesh.getdNodalMassMatrix\n \n \nMethod\n.\n\n\nfunction jInv.Mesh.getdNodalMassMatrix(Mesh,v)\n\nReturns derivative of nodal mass matrix. Matrix is always \nconstructed. Uses pre-constructed nodal averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}\n\n\n\n\nsource", 
            "title": "Mesh"
        }, 
        {
            "location": "/Mesh/#jinvmesh", 
            "text": "Discretization of differential operators is an essential ingredient of PDE parameter estimation problems. Depending on the problem and computational resources, different mesh types are needed in practical applications. The  Mesh  submodule of  jInv  provides different mesh geometry under the abstract type  AbstractMesh . Currently, the  Mesh  submodule methods and provides operators on regular and tensor meshes but is easily extensible.", 
            "title": "jInv.Mesh"
        }, 
        {
            "location": "/Mesh/#regular-meshes", 
            "text": "", 
            "title": "Regular Meshes"
        }, 
        {
            "location": "/Mesh/#list-of-types-and-methods", 
            "text": "#  jInv.Mesh.RegularMesh     Type .  type jInv.Mesh.RegularMesh  : AbstractTensorMesh\n\nRegular mesh in 1D, 2D, and 3D\n\nFields:\n\n    domain::Vector{Float64}  - physical domain [min(x1) max(x1) min(x2) max(x2)]\n    h::Vector{Float64}       - cell size\n    x0::Vector{Float64}      - origin\n    dim::Int                 - dimension of mesh\n    n::Vector{Int64}         - number of cells in each dimension\n    nc::Int                  - total number of cells\n    nf::Vector{Int64}        - number of faces in each dimension\n    ne::Vector{Int64}        - number of edges in each dimension\n\n\n    Persistent Operators:\n\n    Operators should not be accessed directly. They will be built, if needed,\n    when accessing them using specified method. clear!(M) will release all \n    memory.\n\n        Div::SparseMatrixCSC    - divergence (faces -  cell-centers)\n                                  Access via: getDivergenceMatrix(M)\n        Grad::SparseMatrixCSC   - gradient (nodal -  edges)\n                                  Access via: getNodalGradientMatrix(M)\n        Curl::SparseMatrixCSC   - curl (edges -  faces)\n                                  Access via: getCurlMatrix(M)\n        Af::SparseMatrixCSC     - face average (faces -  cell-centers)\n                                  Access via: getFaceAverageMatrix(M)\n        Ae::SparseMatrixCSC     - edge average (edges -  cell-centers)\n                                  Access via: getEdgeAverageMatrix(M)\n        An::SparseMatrixCSC     - nodal average (nodes -  cell-centers)\n                                  Access via: getNodalAverageMatrix(M)\n        V::SparseMatrixCSC      - cell volumes (diagonal matrix)\n                                  Access via: getVolume(M)\n        F::SparseMatrixCSC      - face area (diagonal matrix)\n                                  Access via: getFaceArea(M)\n        L::SparseMatrixCSC      - edge length (diagonal matrix)\n                                  Access via: getLength(M)\n        Vi::SparseMatrixCSC     - inverse cell volumes (diagonal matrix)\n                                  Access via: getVolumeInv(M)\n        Fi::SparseMatrixCSC     - inverse face area (diagonal matrix)\n                                  Access via: getFaceAreaInv(M)\n        Li::SparseMatrixCSC     - inverse edge length (diagonal matrix)\n                                  Access via: getLengthAreaInv(M)\n        nLap::SparseMatrixCSC   - nodal Laplacian\n                                  Access via: getNodalLaplacian(M)\n\nExamples:\nM2D  = getRegularMesh([1.2 2.4 2.2 5.0],[3,4])  \nM3D  = getRegularMesh([1.2 2.4 2.2 5.0 0 1],[3,4,7])  source  #  jInv.Mesh.TensorMesh3D     Type .  type jInv.Mesh.TensorMesh3D  : AbstractTensorMesh\n\nFields:\n\n    h1::Vector{Float64}     - cell size in x1 direction\n    h2::Vector{Float64}     - cell size in x2 direction\n    h3::Vector{Float64}     - cell size in x3 direction\n    x0::Vector{Float64}     - origin\n    dim::Int                - dimension (dim=3)\n    n::Vector{Int64}        - number of cells in each direction\n    nc::Int                 - nc total number of cells (nc=prod(n))\n    nf::Vector{Int64}       - number of faces\n    ne::Vector{Int64}       - number of edges\n\nPersistent Operators:\n\nOperators should not be accessed directly. They will be built, if needed,\nwhen accessing them using specified method. clear!(M) will release all \nmemory.\n\n    Div::SparseMatrixCSC    - divergence (faces -  cell-centers)\n                              Access via: getDivergenceMatrix(M)\n    Grad::SparseMatrixCSC   - gradient (nodal -  edges)\n                              Access via: getNodalGradientMatrix(M)\n    Curl::SparseMatrixCSC   - curl (edges -  faces)\n                              Access via: getCurlMatrix(M)\n    Af::SparseMatrixCSC     - face average (faces -  cell-centers)\n                              Access via: getFaceAverageMatrix(M)\n    Ae::SparseMatrixCSC     - edge average (edges -  cell-centers)\n                              Access via: getEdgeAverageMatrix(M)\n    An::SparseMatrixCSC     - nodal average (nodes -  cell-centers)\n                              Access via: getNodalAverageMatrix(M)\n    V::SparseMatrixCSC      - cell volumes (diagonal matrix)\n                              Access via: getVolume(M)\n    F::SparseMatrixCSC      - face area (diagonal matrix)\n                              Access via: getFaceArea(M)\n    L::SparseMatrixCSC      - edge length (diagonal matrix)\n                              Access via: getLength(M)\n    Vi::SparseMatrixCSC     - inverse cell volumes (diagonal matrix)\n                              Access via: getVolumeInv(M)\n    Fi::SparseMatrixCSC     - inverse face area (diagonal matrix)\n                              Access via: getFaceAreaInv(M)\n    Li::SparseMatrixCSC     - inverse edge length (diagonal matrix)\n                              Access via: getLengthAreaInv(M)\n    nLap::SparseMatrixCSC   - nodal Laplacian\n                              Access via: getNodalLaplacian(M)\n\nExample: \n\nh1 = rand(4); h2 = rand(6); h3 = rand(5);\nM  = getTensorMesh2D(h1,h2,h3)  source  #  jInv.Mesh.getBoundaryNodes     Method .  function jInv.Mesh.getBoundaryNodes(Mesh)  Returns an array tuple (boundary node indices, inner node indices)\n\nInput: \n    Mesh::Abstract Mesh\n\nOutput:\n    Tuple{Array{Int64,1},Array{Int64,1}}  source  #  jInv.Mesh.getEdgeAverageMatrix     Method .  function jInv.Mesh.getEdgeAverageMatrix  Returns Edge-to-CellCenter average matrix from Mesh.Ae. \nMatrix is constructed if Mesh.Ae is empty. \n\nFor 3D Mesh: Ae = [A1 A2 A3]\n\nInput: \n    Mesh::Abstract Mesh  source  #  jInv.Mesh.getEdgeIntegralOfPolygonalChain     Method .      function jInv.Mesh.getEdgeIntegralOfPolygonalChain\n\n    s = getEdgeIntegralPolygonalChain(mesh,polygon)\n    s = getEdgeIntegralPolygonalChain(mesh,polygon,normalize)\n\n    Compute the integral of a piecewise linear edge grid basis projected onto\n    the edges of a polygonal chain. This function can be used to evaluate the\n    source term of a line current carried by the polygonal chain in electromagnetic\n    modelling.\n\n    The piecewise linear edge grid basis consists of the functions\n      phix_i (i = 1 ... numXEdges)\n      phiy_i (i = 1 ... numYEdges)\n      phiz_i (i = 1 ... numZEdges)\n    where phix_i, phiy_i, phiz_i = 1 at the i-th x/y/z-directed edge\n      and phix_i, phiy_i, phiz_i = 0 at all other edges.\n\n    INPUT\n    mesh ...... Tensor mesh\n    polygon ... vertices of polygonal chain as numVertices x 3 array\n    normalize . divide line integral by length of integration path (boolean, optional)\n\n    OUTPUT\n    s ......... source vector\n\n    For a closed current loop, specify polygon such that\n    polygon[1,:] == polygon[end,:]  source  #  jInv.Mesh.getEdgeMassMatrix     Method .  function jInv.Mesh.getEdgeMassMatrix(mesh,sigma)\n\nReturns mass matrix on cell edges, weighted by vector sigma.\nMatrix is always constructed. Uses pre-constructed edge averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source  #  jInv.Mesh.getFaceAverageMatrix     Method .  function jInv.Mesh.getFaceAverageMatrix  Returns Face-to-CellCenter average matrix from Mesh.Af. \nMatrix is constructed if Mesh.Af is empty. \n\nFor 2D Mesh: Af = [A1 A2]\nFor 3D Mesh: Af = [A1 A2 A3]\n\nInput: \n    Mesh::Abstract Mesh  source  #  jInv.Mesh.getFaceMassMatrix     Method .  function jInv.Mesh.getFaceMassMatrix(Mesh,sigma)\n\nReturns face mass matrix, weighted by vector sigma. \nMatrix is always constructed. Uses pre-constructed face averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source  #  jInv.Mesh.getInterpolationMatrix     Method .  function jInv.Mesh.getInterpolationMatrix  computes bi/trilinear interpolation matrix P for cell-centered data from Mesh1 to Mesh2. If I1 is a cell-centerd discretization of some function  on Mesh1 then, its interpolant on Mesh2 is given by  I2 = P*I1  Required Input:  M1::AbstractTensorMesh \nM2::AbstractTensorMesh  Example:  In mesh-decoupling, we use different meshes for the inverse solution\nand the different forward problems. \n\nMesh2Mesh = getInterpolationMatrix(Minv,Mfor)  source  #  jInv.Mesh.getNodalAverageMatrix     Method .  function jInv.Mesh.getNodalAverageMatrix  Returns Nodal-to-CellCenter average matrix from Mesh.An. \nMatrix is constructed if Mesh.An is empty. \n\nInput: \n    Mesh::Abstract Mesh  source  #  jInv.Mesh.getNodalMassMatrix     Method .  function jInv.Mesh.getNodalMassMatrix(Mesh,sigma)\n\nReturns nodal mass matrix, weighted by vector sigma. \nMatrix is always constructed. Uses pre-constructed nodal averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       sigma::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source  #  jInv.Mesh.getRegularMesh     Method .  function jInv.Mesh.getRegularMesh\n\nConstructs regular mesh\n\nInput: \n    domain - physical domain rectangular\n    n      - number of cells in each dimension\n\nExamples:\nM2D  = getRegularMesh([1.2 2.4 2.2 5.0],[3,4])  \nM3D  = getRegularMesh([1.2 2.4 2.2 5.0 0 1],[3,4,7])  source  #  jInv.Mesh.getStraightLineCurrentIntegral     Method .      function jInv.Mesh.getStraightLineCurrentIntegral\n\n    [sx,sy,sz] = getStraightLineCurrentIntegral(hx,hy,hz,ax,ay,az,bx,by,bz)\n\n    Compute integral int(W . J dx^3) in brick of size hx x hy x hz\n    where W denotes the 12 local bilinear edge basis functions\n    and where J prescribes a unit line current\n    between points (ax,ay,az) and (bx,by,bz).  source  #  jInv.Mesh.getTensorMesh3D     Function .  function jInv.Mesh.getTensorMesh3D\n\nconstructs TensorMesh3D\n\nRequired Input:\n\n   h1::Array - cell-sizes in x1 direction\n   h2::Array - cell-sizes in x2 direction\n   h3::Array - cell-sizes in x3 direction\n\nOptional Input\n   x0::Array - origin (default = zeros(3))  source  #  jInv.Mesh.getdEdgeMassMatrix     Method .  function jInv.Mesh.getdEdgeMassMatrix(mesh,v)\n\nReturns derivative of edge mass matrix. Matrix is always \nconstructed. Uses pre-constructed edge averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source  #  jInv.Mesh.getdFaceMassMatrix     Method .  function jInv.Mesh.getdFaceMassMatrix(Mesh,v)\n\nReturns derivative of face mass matrix. Matrix is always \nconstructed. Uses pre-constructed face averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source  #  jInv.Mesh.getdNodalMassMatrix     Method .  function jInv.Mesh.getdNodalMassMatrix(Mesh,v)\n\nReturns derivative of nodal mass matrix. Matrix is always \nconstructed. Uses pre-constructed nodal averaging\nand cell volume matrices if available.\n\nInput: \n    Mesh::Abstract Mesh\n       v::Vector\n\nOutput:\n    SparseMatrixCSC{Float64,Int64}  source", 
            "title": "List of types and methods"
        }, 
        {
            "location": "/LinearSolvers/", 
            "text": "jInv.LinearSolvers\n\n\nThe \nLinearSolvers\n submodule provides wrappers iterative and direct solvers for linear systems such as discretized PDEs.\n\n\n\n\nSupported Packages\n\n\nThe module looks for MUMPS, Pardiso, and SpMatVec. \n\n\n\n\nList of types and methods\n\n\n#\n\n\njInv.LinearSolvers.BlockIterativeSolver\n \n \nType\n.\n\n\ntype BlockIterativeSolver\n\n\nFields:\n\n\nIterMethod - iterative method to apply\nPC      - symbol, (:ssor, :jac,...)\nmaxIter - maximum number of iterations\ntol     - tolerance\nAinv    - preconditioner\nout     - flag for output\ndoClear - flag for deleting preconditioner\nnthreads - number of threads for spmatvecs\nsym      - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose - if true, transpose(A) is provided to solver, else A is proved to solver\n          default=false, use isTranspose=true for efficiency with caution\n          note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC\n\n\n\n\nExample getBlockIterativeSolver()\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.IterativeSolver\n \n \nType\n.\n\n\ntype jInv.LinearSolvers.IterativeSolver \n: AbstractSolver\n\n\nFields:\n\n\nIterMethod - iterative method to apply\nPC      - symbol, (:ssor, :jac,...)\nmaxIter - maximum number of iterations\ntol     - tolerance\nAinv    - preconditioner\nout     - flag for output\ndoClear - flag for deleting preconditioner\nnthreads - number of threads for spmatvecs\nsym      - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose - if true, transpose(A) is provided to solver, else A is provided to solver\n          default=false, use isTranspose=true for efficiency with caution\n          note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC\n\n\n\n\nExample:\n\n\ngetIterativeSolver(cg)\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.JuliaSolver\n \n \nType\n.\n\n\ntype jInv.LinearSolvers.JuliaSolver\n: AbstractSolver\n\n\nFields:\n\n\nAinv         - holds factorization (LU or Cholesky)\nsym          - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTransposed - flag whether A comes transposed or not\ndoClear      - flag to clear factorization\nfacTime      - cumulative time for factorizations\nnSolve       - number of solves\nsolveTime    - cumnulative time for solves\nnFac         - number of factorizations performed\n\n\n\n\nExample: \n\n\nAinv = getJuliaSolver()\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.MUMPSsolver\n \n \nType\n.\n\n\ntype MUMPSsolver\n\n\nFields:\n\n\nAinv    - holds MUMPSfactorization\ndoClear - flag to clear factorization\nooc     - flag for out-of-core option\nsym     - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nnFac    - number of factorizations performed\nfacTime - cumulative time for factorizations\nnSolve  - number of solves\nsolveTime - cumnulative time for solves\n\n\n\n\nExample:\n\n\nAinv = getMUMPSsolver()\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.jInvPardisoSolver\n \n \nType\n.\n\n\ntype jInvPardisoSolver\n\n\nFields:\n\n\nAinv    - holds PardisoFactorization\ndoClear - flag to clear factorization\nooc     - flag for out-of-core option\nsym     - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nnFac    - number of factorizations performed\nfacTime - cumulative time for factorizations\nnSolve  - number of solves\nsolveTime - cumulative time for solves\n\n\n\n\nExample:\n\n\nAinv = getjInvPardisoSolver()\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.getBlockIterativeSolver\n \n \nMethod\n.\n\n\nfunction jInv.LinearSolvers.getBlockIterativeSolver\n\n\nconstructs BlockIterativeSolver\n\n\nRequired Input:\n\n\nIterMethod::Function   - function handle for linear solvers \n    Inputs are: (A,B,M), A is matrix, B are right hand sides, M is preconditioner\n        Examples: \n              IterMethod = blockCG\n              IterMethod(A,B;M=M,X=X,tol=1e-1,maxIter=10,out=-1) =\n                              blockBiCGSTB(A,b,M1=M,X=X,tol=tol,maxIter=maxIter,out=out)\n        The keyword arguments of IterMethod for blockBiCGSTB\n        will be initialized with the fields in the IterativeSolver type.\n    Outputs are: (X,flag,err,iter), X are approximate solutions\n\n\n\n\nOptional Inputs:\n\n\nPC::Symbol     - specifies preconditioner, default:ssor\nmaxIter        - maximum number of iterations, default:500\ntol            - tolerance on relative residual, default=1e-5\nAinv           - preconditioner, default=identity\nout            - flag for output, default=-1 (no output)\ndoClear        - flag for clearing the preconditioner, default=true\nnthreads       - number of threads to use for matvecs (requires ParSpMatVec.jl), default=4\nsym            - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose    - if true, transpose(A) is provided to solver, else A is proved to solver\n                  default=false, use isTranspose=true for efficiency with caution\n                  note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.getIterativeSolver\n \n \nMethod\n.\n\n\nfunction jInv.LinearSolvers.getIterativeSolver\n\n\nconstructs IterativeSolver\n\n\nRequired Input:\n\n\nIterMethod::Function   - function handle for linear solvers \n    Inputs are: (A,b,M), A is matrix, b is right hand side, M is preconditioner\n        Examples: IterMethod = KrylovMethods.cg   #KrylovMethods.cg already has required API\n              IterMethod(A,b;M=M,tol=1e-1,maxIter=10,out=-1) =\n                              bicgstb(A,b,M1=M,tol=tol,maxIter=maxIter,out=out)\n              IterMethod(A,b;M=M,tol=1e-1,maxIter=10,out=-1)  = \n                              gmres(A,b,5,M1=M,tol=tol,maxIter=maxIter,out=out)\n        The keyword arguments of IterMethod for bicgstb and gmres\n        will be initialized with the fields in the IterativeSolver type.\n    Outputs are: (x,flag,err,iter), x is approximate solution\n\n\n\n\nOptional Inputs:\n\n\nPC::Symbol     - specifies preconditioner, default:ssor\nmaxIter        - maximum number of iterations, default:500\ntol            - tolerance on relative residual, default=1e-5\nAinv           - preconditioner, default=identity\nout            - flag for output, default=-1 (no output)\ndoClear        - flag for clearing the preconditioner, default=true\nnthreads       - number of threads to use for matvecs (requires ParSpMatVec.jl), default=4\nsym            - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose    - if true, transpose(A) is provided to solver, else A is proved to solver\n                  default=false, use isTranspose=true for efficiency with caution\n                  note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC\n\n\n\n\nsource\n\n\n#\n\n\njInv.LinearSolvers.getJuliaSolver\n \n \nMethod\n.\n\n\nfunction jInv.LinearSolvers.getJuliaSolver\n\n\nConstructor for JuliaSolver\n\n\nOptional Keyword Arguments\n\n\nAinv = []\nsym = 0\nisTransposed = 0\ndoClear = 0\n\n\n\n\nsource", 
            "title": "LinearSolvers"
        }, 
        {
            "location": "/LinearSolvers/#jinvlinearsolvers", 
            "text": "The  LinearSolvers  submodule provides wrappers iterative and direct solvers for linear systems such as discretized PDEs.", 
            "title": "jInv.LinearSolvers"
        }, 
        {
            "location": "/LinearSolvers/#supported-packages", 
            "text": "The module looks for MUMPS, Pardiso, and SpMatVec.", 
            "title": "Supported Packages"
        }, 
        {
            "location": "/LinearSolvers/#list-of-types-and-methods", 
            "text": "#  jInv.LinearSolvers.BlockIterativeSolver     Type .  type BlockIterativeSolver  Fields:  IterMethod - iterative method to apply\nPC      - symbol, (:ssor, :jac,...)\nmaxIter - maximum number of iterations\ntol     - tolerance\nAinv    - preconditioner\nout     - flag for output\ndoClear - flag for deleting preconditioner\nnthreads - number of threads for spmatvecs\nsym      - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose - if true, transpose(A) is provided to solver, else A is proved to solver\n          default=false, use isTranspose=true for efficiency with caution\n          note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC  Example getBlockIterativeSolver()  source  #  jInv.LinearSolvers.IterativeSolver     Type .  type jInv.LinearSolvers.IterativeSolver  : AbstractSolver  Fields:  IterMethod - iterative method to apply\nPC      - symbol, (:ssor, :jac,...)\nmaxIter - maximum number of iterations\ntol     - tolerance\nAinv    - preconditioner\nout     - flag for output\ndoClear - flag for deleting preconditioner\nnthreads - number of threads for spmatvecs\nsym      - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose - if true, transpose(A) is provided to solver, else A is provided to solver\n          default=false, use isTranspose=true for efficiency with caution\n          note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC  Example:  getIterativeSolver(cg)  source  #  jInv.LinearSolvers.JuliaSolver     Type .  type jInv.LinearSolvers.JuliaSolver : AbstractSolver  Fields:  Ainv         - holds factorization (LU or Cholesky)\nsym          - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTransposed - flag whether A comes transposed or not\ndoClear      - flag to clear factorization\nfacTime      - cumulative time for factorizations\nnSolve       - number of solves\nsolveTime    - cumnulative time for solves\nnFac         - number of factorizations performed  Example:   Ainv = getJuliaSolver()  source  #  jInv.LinearSolvers.MUMPSsolver     Type .  type MUMPSsolver  Fields:  Ainv    - holds MUMPSfactorization\ndoClear - flag to clear factorization\nooc     - flag for out-of-core option\nsym     - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nnFac    - number of factorizations performed\nfacTime - cumulative time for factorizations\nnSolve  - number of solves\nsolveTime - cumnulative time for solves  Example:  Ainv = getMUMPSsolver()  source  #  jInv.LinearSolvers.jInvPardisoSolver     Type .  type jInvPardisoSolver  Fields:  Ainv    - holds PardisoFactorization\ndoClear - flag to clear factorization\nooc     - flag for out-of-core option\nsym     - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nnFac    - number of factorizations performed\nfacTime - cumulative time for factorizations\nnSolve  - number of solves\nsolveTime - cumulative time for solves  Example:  Ainv = getjInvPardisoSolver()  source  #  jInv.LinearSolvers.getBlockIterativeSolver     Method .  function jInv.LinearSolvers.getBlockIterativeSolver  constructs BlockIterativeSolver  Required Input:  IterMethod::Function   - function handle for linear solvers \n    Inputs are: (A,B,M), A is matrix, B are right hand sides, M is preconditioner\n        Examples: \n              IterMethod = blockCG\n              IterMethod(A,B;M=M,X=X,tol=1e-1,maxIter=10,out=-1) =\n                              blockBiCGSTB(A,b,M1=M,X=X,tol=tol,maxIter=maxIter,out=out)\n        The keyword arguments of IterMethod for blockBiCGSTB\n        will be initialized with the fields in the IterativeSolver type.\n    Outputs are: (X,flag,err,iter), X are approximate solutions  Optional Inputs:  PC::Symbol     - specifies preconditioner, default:ssor\nmaxIter        - maximum number of iterations, default:500\ntol            - tolerance on relative residual, default=1e-5\nAinv           - preconditioner, default=identity\nout            - flag for output, default=-1 (no output)\ndoClear        - flag for clearing the preconditioner, default=true\nnthreads       - number of threads to use for matvecs (requires ParSpMatVec.jl), default=4\nsym            - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose    - if true, transpose(A) is provided to solver, else A is proved to solver\n                  default=false, use isTranspose=true for efficiency with caution\n                  note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC  source  #  jInv.LinearSolvers.getIterativeSolver     Method .  function jInv.LinearSolvers.getIterativeSolver  constructs IterativeSolver  Required Input:  IterMethod::Function   - function handle for linear solvers \n    Inputs are: (A,b,M), A is matrix, b is right hand side, M is preconditioner\n        Examples: IterMethod = KrylovMethods.cg   #KrylovMethods.cg already has required API\n              IterMethod(A,b;M=M,tol=1e-1,maxIter=10,out=-1) =\n                              bicgstb(A,b,M1=M,tol=tol,maxIter=maxIter,out=out)\n              IterMethod(A,b;M=M,tol=1e-1,maxIter=10,out=-1)  = \n                              gmres(A,b,5,M1=M,tol=tol,maxIter=maxIter,out=out)\n        The keyword arguments of IterMethod for bicgstb and gmres\n        will be initialized with the fields in the IterativeSolver type.\n    Outputs are: (x,flag,err,iter), x is approximate solution  Optional Inputs:  PC::Symbol     - specifies preconditioner, default:ssor\nmaxIter        - maximum number of iterations, default:500\ntol            - tolerance on relative residual, default=1e-5\nAinv           - preconditioner, default=identity\nout            - flag for output, default=-1 (no output)\ndoClear        - flag for clearing the preconditioner, default=true\nnthreads       - number of threads to use for matvecs (requires ParSpMatVec.jl), default=4\nsym            - 0=unsymmetric, 1=symm. pos def, 2=general symmetric\nisTranspose    - if true, transpose(A) is provided to solver, else A is proved to solver\n                  default=false, use isTranspose=true for efficiency with caution\n                  note that A_mul_B! is slower than Ac_mul_B for SparseMatrixCSC  source  #  jInv.LinearSolvers.getJuliaSolver     Method .  function jInv.LinearSolvers.getJuliaSolver  Constructor for JuliaSolver  Optional Keyword Arguments  Ainv = []\nsym = 0\nisTransposed = 0\ndoClear = 0  source", 
            "title": "List of types and methods"
        }, 
        {
            "location": "/InverseSolve/", 
            "text": "jInv.InverseSolve\n\n\nThe \nInverseSolve\n submodule contains misfit functions, regularizers, optimization and other tools for solving PDE parameter estimation problems. \n\n\n#\n\n\njInv.InverseSolve.GlobalToLocal\n \n \nType\n.\n\n\ntype jInv.InverseSolve.GlobalToLocal\n\n\nMaps global model to local model\n\n\nsigLocal = PForInv*sigGlobal + sigmaBackground\n\n\nFields:     PForInv::SparseMatrixCSC - linear operator between inverse mesh and                                forward mesh, e.g., linear interpolation matrix                                and projection on active set.     sigmaBackground::Vector  - background model\n\n\nConstructors:     getGlobalToLocal(P::SparseMatrixCSC)  getGlobalToLocal(P::SparseMatrixCSC,sigmaBack::Vector)\n\n\nExample:    Mesh2Mesh = getInterpolationMatrix(Minv,Mfwd)   # Minv and Mfwd have different resolutions  sigmaBack = 1.2*ones(Minv.nc)                   # put background conductivity   gloc      = getGlobalToLocal(Mesh2Mesh,sigmaBack)\n\n\nsigLocal     = gloc.PForInv' * sigGlobal + gloc.sigmaBack\n# this call is equivalent, but needed in case the Mesh2Mesh matrix is compressed\nsigLocalFast = interpGlobalToLocal(sigGlobal,gloc.PForInv,gloc.sigmaBack)\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.InverseParam\n \n \nType\n.\n\n\ntype jInv.InverseSolve.InverseParam\n\nType storing parameters for Inversion.\n\nFields:\n    Minv::AbstractMesh\n    modelfun::Function    - model function (evaluated by main worker), see models.jl\n    regularizer::Function - regularizer, see regularizer.jl\n    alpha::Real           - regularization parameter\n    mref::Array           - reference model\n    boundsLow::Vector     - lower bounds for model\n    boundsHigh::Vector    - upper bounds for model\n    maxStep::Real         - maximum step in optimization\n    pcgMaxIter::Int       - maximum number of PCG iterations\n    pcgTol::Real          - tolerance for PCG\n    minUpdate::Real       - stopping criteria\n    maxIter::Int          - maximum number of iterations\n    HesPrec               - A preconditioner for the Hessian.\nConstructor:\n    getInverseParam\n\nExample:\n    Minv = getRegularMesh(domain,n)\n    modelfun = expMod\n    regularizer(m,mref,Minv) = wdiffusionReg(m,mref,Minv)\n    alpha   = 1e-3\n    mref    = zeros(Minv.nc)\n    pInv = getInverseParam(Minv,modelfun,regularizer,alpha,mref)\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.MisfitParam\n \n \nType\n.\n\n\ntype jInv.InverseSolve.MisfitParam\n\n\nType storing information about one term in the misfit\n\n\nF(m) = sum_i^n phi_i(pFor(model(m)),dobs,Wd)\n\n\nFields:\n\n\npFor::ForwardProbType  - forward problem\nWd                     - inverse standard deviation\ndobs                   - observed data\nmisfit::Function       - misfit function\nmodelfun::Function     - model function (evaluated locally)\ngloc                   - mapping from inverse to forward mesh (including active cells projection).\n\n\n\n\nConstructors:\n\n\ngetMisfitParam(pFor,Wd,dobs,misfit,model,gloc=getGlobalToLocal(1.0))\n\n\ngetMisfitParam(pForRFs::Array{RemoteChannel}, Wd::Array, dobs::Array, misfit::Function,                             Iact,sigmaBack::Vector,                             Mesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}=ones(length(pForRFs)),                             modelfun::Function=identityMod,fname=\"\")\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.HuberFun\n \n \nFunction\n.\n\n\nmis,dmis,d2mis = HuberFun(dc,dobs,Wd,C)\n\nComputes misfit via\n\n    misfit(dc,dobs) = sqrt(abs(Wd*res).^2 + eps)\n\nInput:\n    dc::Array   -  simulated data\n    dobs::Array -  measured data\n    Wd::Array   -  diagional weighting\n    eps         -  conditioning parameter (default=1e-3)\n\nOutput:\n    mis::Real   -  misfit\n    dmis        -  gradient\n    d2mis       -  diagonal of Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.SSDFun\n \n \nMethod\n.\n\n\nFor complex data misfit is computed as 0.5*|real(dc)-(dobs)|_Wd^2 +  0.5*|complex(dc)-complex(dobs)|_W^2\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.SSDFun\n \n \nMethod\n.\n\n\nmis,dmis,d2mis = SSDFun(dc,dobs,Wd)\n\nInput:\n\n    dc::Array   -  simulated data\n    dobs::Array -  measured data\n    Wd::Array   -  diagonal weighting\n\nOutput:\n\n    mis::Real   -  misfit, 0.5*|dc-dobs|_Wd^2\n    dmis        -  gradient\n    d2mis       -  diagonal of Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.boundMod\n \n \nMethod\n.\n\n\nsigma,dsigma = boundMod(m;boundLow=0.0,boundHigh=1.0)\n\nmaps model parameter to conductivity via\n\n    sigma = 0.5*(boundHigh-boundLow) * (tanh(m)+1.0 ) + boundLow\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.computeMisfit\n \n \nFunction\n.\n\n\nDc,F,dF,d2F = computeMisfit(...)\n\nComputes misfit for PDE parameter estimation problem.\n\ncomputeMisfit has several options.\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.diffusionReg\n \n \nMethod\n.\n\n\nRc,dR,d2R = diffusionReg(m,mref,M,Iact=1.0)\n\nCompute diffusion regularizer\n    0.5*||GRAD*(m-mref)||_V^2\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.expMod\n \n \nMethod\n.\n\n\nsigma,dsigma = expMod(model)\n\nmaps model parameter to conductivity via\n\nsigma(m) = exp(m)\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.fMod\n \n \nMethod\n.\n\n\nsigma,dsigma = fMod(model;f::Function=identity,df::Function=m-\nspeye(length(m)))\n\nmaps model parameter to conductivity via\n\nsigma(m) = f(m) and dsigma(m) = sdiag(df(m))\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.getInverseParam\n \n \nMethod\n.\n\n\nfunction jInv.InverseSolve.getInverseParam(...)\n\n\nConstructs an InverseParam\n\n\nRequired Input:\n\n\nMinv::AbstractMesh    - mesh of model\nmodFun::Function      - model\nregularizer::Function - regularizer, see regularizer.jl\nalpha::Real           - regularization parameter\nmref                  - reference model\nboundsLow::Vector     - lower bounds for model\nboundsHigh::Vector    - upper bounds for model\n\n\n\n\nOptional Inputs:\n\n\nmaxStep::Real=1.0     - maximum step in optimization\npcgMaxIter::Int=10    - maximum number of PCG iterations\npcgTol::Real          - tolerance for PCG\nminUpdate::Real=1e-4  - stopping criteria\nmaxIter::Int=10       - maximum number of iterations\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.getMisfitParam\n \n \nFunction\n.\n\n\nfunction jInv.InverseSolve.getMisfitParam\n\n\nRequired Input:\n\n\nInput for a call:   getMisfitParam(pFor,Wd,dobs,misfit,model,gloc=getGlobalToLocal(1.0))\n\n\npFor::ForwardProbType  - forward problem\nWd                     - inverse standard deviation of data\ndobs                   - observed data\nmisfit::Function       - Misfit function\nmodelfun::Function     - model function. If all misfits have same model function,\n                         put modelfun in inverseParam and identityMod here for efficiency.\ngloc                   - mapping from inverse to forward mesh (default: identity). See globalToLocal.jl\n\n\n\n\nInput for a call:   getMisfitParam(pForRFs::Array{RemoteChannel}, Wd::Array, dobs::Array, misfit::Function,                             Iact,sigmaBack::Vector, Mesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}=ones(length(pForRFs)),                             modelfun::Function=identityMod,fname=\"\")\n\n\npForRFs::Array{RemoteChannel}                   - Array of remote references for forward problem parameters on each worker.\nWd::Array                               - Array of inverse standard deviation for the data on each worker.\ndobs::Array                             - Array of observed data for each worker.\nmisfit::Function                            - Misfit function\nIact                                        - Projector to active cells.\nsigmaBack::Vector                           - Background model (\nfrozen\n cells).\nMesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}    - mapping from inverse to forward mesh (default: identity)\nmodelfun::Function=identityMod                      - model function. If all misfits have same model function,\n                                      put modelfun in inverseParam and identityMod here for efficiency.\nfname=\n                                - (optional)\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.iteratedTikhonov\n \n \nMethod\n.\n\n\nmc,DC = iteratedTikhonov(mc,pInv::InverseParam,pMis,nAlpha,alphaFac,\n                        targetMisfit;indCredit=[],dumpResults::Function=dummy)\n\nPerform (Projected) Gauss-NewtonCG using iterated Tikhonov procedure to decrease\nregularization parameter and update reference model after fixed number of GN iterations\nset in pInv.\n\nInput:\n       mc::Vector         - Initial guess for model\n       pInv::InverseParam - parameter for inversion\n       pMis               - misfit terms\n       nAlpha             - maximum number of allowed regularization parameter (alpha) values\n       alphaFac           - alpha decrease factor. alpha_(i+1) = alpha_i/alphaFac\n       targetMisfit       - Termination criterion. iteratedTikhonov will exit \n                             -when data misfit \n targetMisfit\n       indCredit          - indices of forward problems to work on\n       dumpResults        - A function pointer for saving the results throughout the iterations.\n                             - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis), \n                             - where mc is the recovered model, Dc is the predicted data. \n                             - If dumpResults is not given, nothing is done (dummy() is called).\n\nOutput:\n       mc                 - final model\n       Dc                 - final computed data\n       tikhonovFlag       - Data misfit convergence flag\n       hist               - Iteration history. This is a vector. Each entry is\n                             - a structure containing the projGNCG history for each\n                             - alpha value.\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.logBarrier\n \n \nFunction\n.\n\n\nRc,dR,d2R = logBarrier(m::Vector, z::Vector, M::AbstractMesh,low::Vector,high::Vector, epsilon)\n\nComputes logBarrier regularizer\n\nR = -log(1 - ((m-high)/epsilon).^2) if high-epsilon \n  m \n high\n                0                   if low+epsilon  \n= m \n= high-epsilon\n    -log(1 - ((m-low)/epsilon).^2)  if low          \n  m \n low+epsilon\n\nInput:\n    m       - model\n    z       - not being used. Here for compatibility.\n    M       - Mesh. not being used. Here for compatibility.\n    low     - low bound for each coordinate.\n    high    - high bound for each coordinate.\n    epsilon - layer width of the barier.\n\nOutput\n    g    - value of regularizer\n    dg    - gradient w.r.t. m\n    d2g   - Hessian (diagonal matrix). Second derivative is not continous.\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.logBarrierSquared\n \n \nFunction\n.\n\n\nRc,dR,d2R = logBarrierSquared(m::Vector, z::Vector, M::AbstractMesh,low::Vector,high::Vector, epsilon)\n\nComputes logBarrier regularizer\n\nR = (log(1 - ((m-high)/epsilon).^2))^2 if high-epsilon \n  m \n high\n                0                      if low+epsilon  \n= m \n= high-epsilon\n    (log(1 - ((m-low)/epsilon).^2))^2  if low          \n  m \n low+epsilon\n\nInput:\n    m       - model\n    z       - not being used. Here for compatibility.\n    M       - Mesh. not being used. Here for compatibility.\n    low     - low bound for each coordinate.\n    high    - high bound for each coordinate.\n    epsilon - layer width of the barier.\n\nOutput\n    g    - value of regularizer\n    dg    - gradient w.r.t. m\n    d2g   - Gauss Newton Hessian approximation (diagonal matrix). Second derivative approx is continous.\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.projGNCG\n \n \nMethod\n.\n\n\nmc,Dc,outerFlag = projGNCG(mc,pInv::InverseParam,pMis, indFor = [], dumpResults::Function = dummy)\n\n(Projected) Gauss-NewtonCG\n\nInput:\n\n    mc::Vector          - intial guess for model\n    pInv::InverseParam  - parameter for inversion\n    pMis                - misfit terms\n    indCredit           - indices of forward problems to work on\n    dumpResults         - A function pointer for saving the results throughout the iterations.\n                        - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis),\n                        - where mc is the recovered model, Dc is the predicted data.\n                        - If dumpResults is not given, nothing is done (dummy() is called).\n    out::Int            - flag for output (-1: no output, 1: final status, 2: residual norm at each iteration)\n\nOutput:\n    mc                  - final model\n    Dc                  - data\n    outerFlag           - flag for convergence\n    His                 - iteration history\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.projPCG\n \n \nMethod\n.\n\n\ndm = projPCG(H,g,Active,Precond,cgTol,maxIter)\n\nProjected Preconditioned Conjugate Gradient method for solving\n\n    H*dm = g    subject to    dm[!Active] == 0 \n\nInput:\n\n    H::Function       -  computes action of Hessian\n    g::Vector         -  right hand side\n    Active            -  describes active cells\n    Precond::Function - preconditioner\n    cgTol             - tolerance\n    maxIter             - maximum number of iterations\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.projSD\n \n \nMethod\n.\n\n\nmc,Dc,outerFlag = projSD(mc,pInv::InverseParam,pMis, indFor = [], dumpResults::Function = dummy)\n\n(Projected) Steepest Descent method for solving\n\n    min_x misfit(x) + regularizer(x) subject to  x in C\n\nwhere C is a convex set and a projection operator proj(x) needs to be provided.\n\nInput:\n\n    mc::Vector          - intial guess for model\n    pInv::InverseParam  - parameter for inversion\n    pMis                - misfit terms\n    indCredit           - indices of forward problems to work on\n    dumpResults         - A function pointer for saving the results throughout the iterations.\n                        - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis),\n                        - where mc is the recovered model, Dc is the predicted data.\n                        - If dumpResults is not given, nothing is done (dummy() is called).\n    out::Int            - flag for output (-1: no output, 1: final status, 2: residual norm at each iteration)\n\nOutput:\n    mc                  - final model\n    Dc                  - data\n    outerFlag           - flag for convergence\n    His                 - iteration history\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.smallnessReg\n \n \nMethod\n.\n\n\nRc,dR,d2R = smallnessReg(m,mref,M,Iact=1.0)\n\nCompute smallness regularizer (L2 difference to reference model)\n\n    R(m) = 0.5*||m-mref||_V^2\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.wTVReg\n \n \nMethod\n.\n\n\nRc,dR,d2R = wTVReg(m,mref,M,Iact,C=[])\n\nCompute weighted total variation regularizer\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n    C     - anisotropy parameters (default: [1 1 1])\n    eps   - conditioning parameter for TV norm (default: 1e-3)\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.wdiffusionRegNodal\n \n \nMethod\n.\n\n\nRc,dR,d2R = wdiffusionRegNodal(m::Vector, mref::Vector, M::AbstractMesh; Iact=1.0, C=[])\n\nComputes weighted diffusion regularizer for nodal model\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n    C     - optional parameters\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian\n\n\n\n\nsource\n\n\n#\n\n\njInv.InverseSolve.projGrad\n \n \nMethod\n.\n\n\nfunction projGrad\n\nProjects gradient, i.e.,\n\n                 | gc[i],               xl[i] \n x[i] \n xh[i]\ngc[i]  = | max(gc[i],0)     xc[i] == xh[i]\n                 | min(gc[i],0)   xc[i] == xl[i]\n\n\nInput:\n\n    gc                - gradient vector\n    mc                - model\n    boundsLow   - lower bounds\n    boundsHigh  - upper bounds\n\n\n\n\nsource", 
            "title": "InverseSolve"
        }, 
        {
            "location": "/InverseSolve/#jinvinversesolve", 
            "text": "The  InverseSolve  submodule contains misfit functions, regularizers, optimization and other tools for solving PDE parameter estimation problems.   #  jInv.InverseSolve.GlobalToLocal     Type .  type jInv.InverseSolve.GlobalToLocal  Maps global model to local model  sigLocal = PForInv*sigGlobal + sigmaBackground  Fields:     PForInv::SparseMatrixCSC - linear operator between inverse mesh and                                forward mesh, e.g., linear interpolation matrix                                and projection on active set.     sigmaBackground::Vector  - background model  Constructors:     getGlobalToLocal(P::SparseMatrixCSC)  getGlobalToLocal(P::SparseMatrixCSC,sigmaBack::Vector)  Example:    Mesh2Mesh = getInterpolationMatrix(Minv,Mfwd)   # Minv and Mfwd have different resolutions  sigmaBack = 1.2*ones(Minv.nc)                   # put background conductivity   gloc      = getGlobalToLocal(Mesh2Mesh,sigmaBack)  sigLocal     = gloc.PForInv' * sigGlobal + gloc.sigmaBack\n# this call is equivalent, but needed in case the Mesh2Mesh matrix is compressed\nsigLocalFast = interpGlobalToLocal(sigGlobal,gloc.PForInv,gloc.sigmaBack)  source  #  jInv.InverseSolve.InverseParam     Type .  type jInv.InverseSolve.InverseParam\n\nType storing parameters for Inversion.\n\nFields:\n    Minv::AbstractMesh\n    modelfun::Function    - model function (evaluated by main worker), see models.jl\n    regularizer::Function - regularizer, see regularizer.jl\n    alpha::Real           - regularization parameter\n    mref::Array           - reference model\n    boundsLow::Vector     - lower bounds for model\n    boundsHigh::Vector    - upper bounds for model\n    maxStep::Real         - maximum step in optimization\n    pcgMaxIter::Int       - maximum number of PCG iterations\n    pcgTol::Real          - tolerance for PCG\n    minUpdate::Real       - stopping criteria\n    maxIter::Int          - maximum number of iterations\n    HesPrec               - A preconditioner for the Hessian.\nConstructor:\n    getInverseParam\n\nExample:\n    Minv = getRegularMesh(domain,n)\n    modelfun = expMod\n    regularizer(m,mref,Minv) = wdiffusionReg(m,mref,Minv)\n    alpha   = 1e-3\n    mref    = zeros(Minv.nc)\n    pInv = getInverseParam(Minv,modelfun,regularizer,alpha,mref)  source  #  jInv.InverseSolve.MisfitParam     Type .  type jInv.InverseSolve.MisfitParam  Type storing information about one term in the misfit  F(m) = sum_i^n phi_i(pFor(model(m)),dobs,Wd)  Fields:  pFor::ForwardProbType  - forward problem\nWd                     - inverse standard deviation\ndobs                   - observed data\nmisfit::Function       - misfit function\nmodelfun::Function     - model function (evaluated locally)\ngloc                   - mapping from inverse to forward mesh (including active cells projection).  Constructors:  getMisfitParam(pFor,Wd,dobs,misfit,model,gloc=getGlobalToLocal(1.0))  getMisfitParam(pForRFs::Array{RemoteChannel}, Wd::Array, dobs::Array, misfit::Function,                             Iact,sigmaBack::Vector,                             Mesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}=ones(length(pForRFs)),                             modelfun::Function=identityMod,fname=\"\")  source  #  jInv.InverseSolve.HuberFun     Function .  mis,dmis,d2mis = HuberFun(dc,dobs,Wd,C)\n\nComputes misfit via\n\n    misfit(dc,dobs) = sqrt(abs(Wd*res).^2 + eps)\n\nInput:\n    dc::Array   -  simulated data\n    dobs::Array -  measured data\n    Wd::Array   -  diagional weighting\n    eps         -  conditioning parameter (default=1e-3)\n\nOutput:\n    mis::Real   -  misfit\n    dmis        -  gradient\n    d2mis       -  diagonal of Hessian  source  #  jInv.InverseSolve.SSDFun     Method .  For complex data misfit is computed as 0.5*|real(dc)-(dobs)|_Wd^2 +  0.5*|complex(dc)-complex(dobs)|_W^2  source  #  jInv.InverseSolve.SSDFun     Method .  mis,dmis,d2mis = SSDFun(dc,dobs,Wd)\n\nInput:\n\n    dc::Array   -  simulated data\n    dobs::Array -  measured data\n    Wd::Array   -  diagonal weighting\n\nOutput:\n\n    mis::Real   -  misfit, 0.5*|dc-dobs|_Wd^2\n    dmis        -  gradient\n    d2mis       -  diagonal of Hessian  source  #  jInv.InverseSolve.boundMod     Method .  sigma,dsigma = boundMod(m;boundLow=0.0,boundHigh=1.0)\n\nmaps model parameter to conductivity via\n\n    sigma = 0.5*(boundHigh-boundLow) * (tanh(m)+1.0 ) + boundLow  source  #  jInv.InverseSolve.computeMisfit     Function .  Dc,F,dF,d2F = computeMisfit(...)\n\nComputes misfit for PDE parameter estimation problem.\n\ncomputeMisfit has several options.  source  #  jInv.InverseSolve.diffusionReg     Method .  Rc,dR,d2R = diffusionReg(m,mref,M,Iact=1.0)\n\nCompute diffusion regularizer\n    0.5*||GRAD*(m-mref)||_V^2\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian  source  #  jInv.InverseSolve.expMod     Method .  sigma,dsigma = expMod(model)\n\nmaps model parameter to conductivity via\n\nsigma(m) = exp(m)  source  #  jInv.InverseSolve.fMod     Method .  sigma,dsigma = fMod(model;f::Function=identity,df::Function=m- speye(length(m)))\n\nmaps model parameter to conductivity via\n\nsigma(m) = f(m) and dsigma(m) = sdiag(df(m))  source  #  jInv.InverseSolve.getInverseParam     Method .  function jInv.InverseSolve.getInverseParam(...)  Constructs an InverseParam  Required Input:  Minv::AbstractMesh    - mesh of model\nmodFun::Function      - model\nregularizer::Function - regularizer, see regularizer.jl\nalpha::Real           - regularization parameter\nmref                  - reference model\nboundsLow::Vector     - lower bounds for model\nboundsHigh::Vector    - upper bounds for model  Optional Inputs:  maxStep::Real=1.0     - maximum step in optimization\npcgMaxIter::Int=10    - maximum number of PCG iterations\npcgTol::Real          - tolerance for PCG\nminUpdate::Real=1e-4  - stopping criteria\nmaxIter::Int=10       - maximum number of iterations  source  #  jInv.InverseSolve.getMisfitParam     Function .  function jInv.InverseSolve.getMisfitParam  Required Input:  Input for a call:   getMisfitParam(pFor,Wd,dobs,misfit,model,gloc=getGlobalToLocal(1.0))  pFor::ForwardProbType  - forward problem\nWd                     - inverse standard deviation of data\ndobs                   - observed data\nmisfit::Function       - Misfit function\nmodelfun::Function     - model function. If all misfits have same model function,\n                         put modelfun in inverseParam and identityMod here for efficiency.\ngloc                   - mapping from inverse to forward mesh (default: identity). See globalToLocal.jl  Input for a call:   getMisfitParam(pForRFs::Array{RemoteChannel}, Wd::Array, dobs::Array, misfit::Function,                             Iact,sigmaBack::Vector, Mesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}=ones(length(pForRFs)),                             modelfun::Function=identityMod,fname=\"\")  pForRFs::Array{RemoteChannel}                   - Array of remote references for forward problem parameters on each worker.\nWd::Array                               - Array of inverse standard deviation for the data on each worker.\ndobs::Array                             - Array of observed data for each worker.\nmisfit::Function                            - Misfit function\nIact                                        - Projector to active cells.\nsigmaBack::Vector                           - Background model ( frozen  cells).\nMesh2MeshRFs::Union{Array{RemoteChannel},Array{Float64}}    - mapping from inverse to forward mesh (default: identity)\nmodelfun::Function=identityMod                      - model function. If all misfits have same model function,\n                                      put modelfun in inverseParam and identityMod here for efficiency.\nfname=                                 - (optional)  source  #  jInv.InverseSolve.iteratedTikhonov     Method .  mc,DC = iteratedTikhonov(mc,pInv::InverseParam,pMis,nAlpha,alphaFac,\n                        targetMisfit;indCredit=[],dumpResults::Function=dummy)\n\nPerform (Projected) Gauss-NewtonCG using iterated Tikhonov procedure to decrease\nregularization parameter and update reference model after fixed number of GN iterations\nset in pInv.\n\nInput:\n       mc::Vector         - Initial guess for model\n       pInv::InverseParam - parameter for inversion\n       pMis               - misfit terms\n       nAlpha             - maximum number of allowed regularization parameter (alpha) values\n       alphaFac           - alpha decrease factor. alpha_(i+1) = alpha_i/alphaFac\n       targetMisfit       - Termination criterion. iteratedTikhonov will exit \n                             -when data misfit   targetMisfit\n       indCredit          - indices of forward problems to work on\n       dumpResults        - A function pointer for saving the results throughout the iterations.\n                             - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis), \n                             - where mc is the recovered model, Dc is the predicted data. \n                             - If dumpResults is not given, nothing is done (dummy() is called).\n\nOutput:\n       mc                 - final model\n       Dc                 - final computed data\n       tikhonovFlag       - Data misfit convergence flag\n       hist               - Iteration history. This is a vector. Each entry is\n                             - a structure containing the projGNCG history for each\n                             - alpha value.  source  #  jInv.InverseSolve.logBarrier     Function .  Rc,dR,d2R = logBarrier(m::Vector, z::Vector, M::AbstractMesh,low::Vector,high::Vector, epsilon)\n\nComputes logBarrier regularizer\n\nR = -log(1 - ((m-high)/epsilon).^2) if high-epsilon    m   high\n                0                   if low+epsilon   = m  = high-epsilon\n    -log(1 - ((m-low)/epsilon).^2)  if low             m   low+epsilon\n\nInput:\n    m       - model\n    z       - not being used. Here for compatibility.\n    M       - Mesh. not being used. Here for compatibility.\n    low     - low bound for each coordinate.\n    high    - high bound for each coordinate.\n    epsilon - layer width of the barier.\n\nOutput\n    g    - value of regularizer\n    dg    - gradient w.r.t. m\n    d2g   - Hessian (diagonal matrix). Second derivative is not continous.  source  #  jInv.InverseSolve.logBarrierSquared     Function .  Rc,dR,d2R = logBarrierSquared(m::Vector, z::Vector, M::AbstractMesh,low::Vector,high::Vector, epsilon)\n\nComputes logBarrier regularizer\n\nR = (log(1 - ((m-high)/epsilon).^2))^2 if high-epsilon    m   high\n                0                      if low+epsilon   = m  = high-epsilon\n    (log(1 - ((m-low)/epsilon).^2))^2  if low             m   low+epsilon\n\nInput:\n    m       - model\n    z       - not being used. Here for compatibility.\n    M       - Mesh. not being used. Here for compatibility.\n    low     - low bound for each coordinate.\n    high    - high bound for each coordinate.\n    epsilon - layer width of the barier.\n\nOutput\n    g    - value of regularizer\n    dg    - gradient w.r.t. m\n    d2g   - Gauss Newton Hessian approximation (diagonal matrix). Second derivative approx is continous.  source  #  jInv.InverseSolve.projGNCG     Method .  mc,Dc,outerFlag = projGNCG(mc,pInv::InverseParam,pMis, indFor = [], dumpResults::Function = dummy)\n\n(Projected) Gauss-NewtonCG\n\nInput:\n\n    mc::Vector          - intial guess for model\n    pInv::InverseParam  - parameter for inversion\n    pMis                - misfit terms\n    indCredit           - indices of forward problems to work on\n    dumpResults         - A function pointer for saving the results throughout the iterations.\n                        - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis),\n                        - where mc is the recovered model, Dc is the predicted data.\n                        - If dumpResults is not given, nothing is done (dummy() is called).\n    out::Int            - flag for output (-1: no output, 1: final status, 2: residual norm at each iteration)\n\nOutput:\n    mc                  - final model\n    Dc                  - data\n    outerFlag           - flag for convergence\n    His                 - iteration history  source  #  jInv.InverseSolve.projPCG     Method .  dm = projPCG(H,g,Active,Precond,cgTol,maxIter)\n\nProjected Preconditioned Conjugate Gradient method for solving\n\n    H*dm = g    subject to    dm[!Active] == 0 \n\nInput:\n\n    H::Function       -  computes action of Hessian\n    g::Vector         -  right hand side\n    Active            -  describes active cells\n    Precond::Function - preconditioner\n    cgTol             - tolerance\n    maxIter             - maximum number of iterations  source  #  jInv.InverseSolve.projSD     Method .  mc,Dc,outerFlag = projSD(mc,pInv::InverseParam,pMis, indFor = [], dumpResults::Function = dummy)\n\n(Projected) Steepest Descent method for solving\n\n    min_x misfit(x) + regularizer(x) subject to  x in C\n\nwhere C is a convex set and a projection operator proj(x) needs to be provided.\n\nInput:\n\n    mc::Vector          - intial guess for model\n    pInv::InverseParam  - parameter for inversion\n    pMis                - misfit terms\n    indCredit           - indices of forward problems to work on\n    dumpResults         - A function pointer for saving the results throughout the iterations.\n                        - We assume that dumpResults is dumpResults(mc,Dc,iter,pInv,pMis),\n                        - where mc is the recovered model, Dc is the predicted data.\n                        - If dumpResults is not given, nothing is done (dummy() is called).\n    out::Int            - flag for output (-1: no output, 1: final status, 2: residual norm at each iteration)\n\nOutput:\n    mc                  - final model\n    Dc                  - data\n    outerFlag           - flag for convergence\n    His                 - iteration history  source  #  jInv.InverseSolve.smallnessReg     Method .  Rc,dR,d2R = smallnessReg(m,mref,M,Iact=1.0)\n\nCompute smallness regularizer (L2 difference to reference model)\n\n    R(m) = 0.5*||m-mref||_V^2\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian  source  #  jInv.InverseSolve.wTVReg     Method .  Rc,dR,d2R = wTVReg(m,mref,M,Iact,C=[])\n\nCompute weighted total variation regularizer\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n    C     - anisotropy parameters (default: [1 1 1])\n    eps   - conditioning parameter for TV norm (default: 1e-3)\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian  source  #  jInv.InverseSolve.wdiffusionRegNodal     Method .  Rc,dR,d2R = wdiffusionRegNodal(m::Vector, mref::Vector, M::AbstractMesh; Iact=1.0, C=[])\n\nComputes weighted diffusion regularizer for nodal model\n\nInput:\n    m     - model\n    mref  - reference model\n    M     - Mesh\n    Iact  - projector on active cells\n    C     - optional parameters\n\nOutput\n    Rc    - value of regularizer\n    dR    - gradient w.r.t. m\n    d2R   - Hessian  source  #  jInv.InverseSolve.projGrad     Method .  function projGrad\n\nProjects gradient, i.e.,\n\n                 | gc[i],               xl[i]   x[i]   xh[i]\ngc[i]  = | max(gc[i],0)     xc[i] == xh[i]\n                 | min(gc[i],0)   xc[i] == xl[i]\n\n\nInput:\n\n    gc                - gradient vector\n    mc                - model\n    boundsLow   - lower bounds\n    boundsHigh  - upper bounds  source", 
            "title": "jInv.InverseSolve"
        }, 
        {
            "location": "/ForwardShare/", 
            "text": "jInv.ForwardShare\n\n\nThe \nForwardShare\n submodule provides methods that are useful for different forward problems such as mesh-to-mesh interpolation, parallelization, etc. \n\n\n\n\nList of types and methods\n\n\n#\n\n\njInv.ForwardShare.getNumberOfData\n \n \nMethod\n.\n\n\nnd = getNumberOfData(pFor)\n\n\nReturns number of data in forward problem\n\n\nsource\n\n\n#\n\n\njInv.ForwardShare.getSensMat\n \n \nMethod\n.\n\n\nS = function getSensMat(...)\n\n\nconstructs sensitivity matrix. \n\n\nWARNING: For large-scale problems this will be prohibively           expensive. Use with caution \n\n\nInputs:\n\n\nm    - model\npFor - forward problems\n\n\n\n\nExamples: \n\n\nS = getSensMat(m,pFor)            # single pFor\nS = getSensMat(m,[pFor1;pFor2])   # multiple pFor's\nS = getSensMat(m,pForRef)         # pFor as remote reference\n\n\n\n\nsource\n\n\n#\n\n\njInv.ForwardShare.getSensMatSize\n \n \nMethod\n.\n\n\n(m,n) = getSensMatSize(pFor)\n\n\nReturns size of sensitivity matrix where m is the number of data points and n the number of parameters in the model.\n\n\nInput\n\n\npFor - forward problem:: Union{ForwardProbType, Array, RemoteChannel}\n\n\n\n\nThis is problem dependent and should be implemented in the respective packages.\n\n\nsource\n\n\n#\n\n\njInv.ForwardShare.getSensMatVec\n \n \nMethod\n.\n\n\nJv  = getSensMatVec(v::Vector,m::Vector,param::ForwardProbType)\n\n\nComputes matrix-vector product with the Jacobian.\n\n\nsource\n\n\n#\n\n\njInv.ForwardShare.getSensTMatVec\n \n \nMethod\n.\n\n\nJTv  = getSensMatVec(v::Vector,m::Vector,param::ForwardProbType)\n\n\nComputes matrix-vector product with the transpose of Jacobian. Implementation depends on forward problem.\n\n\nsource", 
            "title": "ForwardShare"
        }, 
        {
            "location": "/ForwardShare/#jinvforwardshare", 
            "text": "The  ForwardShare  submodule provides methods that are useful for different forward problems such as mesh-to-mesh interpolation, parallelization, etc.", 
            "title": "jInv.ForwardShare"
        }, 
        {
            "location": "/ForwardShare/#list-of-types-and-methods", 
            "text": "#  jInv.ForwardShare.getNumberOfData     Method .  nd = getNumberOfData(pFor)  Returns number of data in forward problem  source  #  jInv.ForwardShare.getSensMat     Method .  S = function getSensMat(...)  constructs sensitivity matrix.   WARNING: For large-scale problems this will be prohibively           expensive. Use with caution   Inputs:  m    - model\npFor - forward problems  Examples:   S = getSensMat(m,pFor)            # single pFor\nS = getSensMat(m,[pFor1;pFor2])   # multiple pFor's\nS = getSensMat(m,pForRef)         # pFor as remote reference  source  #  jInv.ForwardShare.getSensMatSize     Method .  (m,n) = getSensMatSize(pFor)  Returns size of sensitivity matrix where m is the number of data points and n the number of parameters in the model.  Input  pFor - forward problem:: Union{ForwardProbType, Array, RemoteChannel}  This is problem dependent and should be implemented in the respective packages.  source  #  jInv.ForwardShare.getSensMatVec     Method .  Jv  = getSensMatVec(v::Vector,m::Vector,param::ForwardProbType)  Computes matrix-vector product with the Jacobian.  source  #  jInv.ForwardShare.getSensTMatVec     Method .  JTv  = getSensMatVec(v::Vector,m::Vector,param::ForwardProbType)  Computes matrix-vector product with the transpose of Jacobian. Implementation depends on forward problem.  source", 
            "title": "List of types and methods"
        }, 
        {
            "location": "/Vis/", 
            "text": "jInv.Vis\n\n\nSubmodule for visualization of functions or meshes based on PyPlot. \n\n\n\n\nList of types and methods", 
            "title": "Vis"
        }, 
        {
            "location": "/Vis/#jinvvis", 
            "text": "Submodule for visualization of functions or meshes based on PyPlot.", 
            "title": "jInv.Vis"
        }, 
        {
            "location": "/Vis/#list-of-types-and-methods", 
            "text": "", 
            "title": "List of types and methods"
        }, 
        {
            "location": "/Utils/", 
            "text": "jInv.Utils\n\n\nThe \nUtils\n submodule provides some basic utility functions used in many parts of jInv. For example, it provides derivative testing and methods for clearing variables. \n\n\n\n\nList of methods\n\n\n#\n\n\njInv.Utils.initRemoteChannel\n \n \nMethod\n.\n\n\nfunction ref = initRemoteChannel(f,pid,args...)\n\n\nRuns the function f with arguments args on worker\n\n\ninput:         func::Union{Function,Type} \u2013 function or type constructor         pid::Int64 \u2013 worker that will run f and store result        args::varargs \u2013 Arguments of f. These must be available on worker pid\n\n\noutput:         ref::RemoteChannel \u2013 Reusable reference to output of f.\n\n\nsource", 
            "title": "Utils"
        }, 
        {
            "location": "/Utils/#jinvutils", 
            "text": "The  Utils  submodule provides some basic utility functions used in many parts of jInv. For example, it provides derivative testing and methods for clearing variables.", 
            "title": "jInv.Utils"
        }, 
        {
            "location": "/Utils/#list-of-methods", 
            "text": "#  jInv.Utils.initRemoteChannel     Method .  function ref = initRemoteChannel(f,pid,args...)  Runs the function f with arguments args on worker  input:         func::Union{Function,Type} \u2013 function or type constructor         pid::Int64 \u2013 worker that will run f and store result        args::varargs \u2013 Arguments of f. These must be available on worker pid  output:         ref::RemoteChannel \u2013 Reusable reference to output of f.  source", 
            "title": "List of methods"
        }, 
        {
            "location": "/About/", 
            "text": "About jInv\n\n\nThis page collects contributors, funding, and outcomes of the jInv project. Please create a pull-request if you actively contribute to jInv or show your support when using jInv in your research.\n\n\n\n\nContributors (in alphabetical order)\n\n\n\n\nPatrick Belliveau (University of British Columbia)\n\n\nEldad Haber (University of British Columbia)\n\n\nLars Ruthotto (Emory University)\n\n\nEran Treister (Ben Gurion University)\n\n\nSamy Wu Fung (Emory University)\n\n\n\n\n\n\nAcknowledgements\n\n\nThis material is in part based upon work supported by the National Science Foundation under Grant Number 1522599. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.\n\n\n\n\nPublications using jInv\n\n\n\n\nRuthotto L, Treister E, Haber E: \njInv - a flexible Julia package for PDE parameter estimation\n, arXiv:1606.0739 [cs.MS] 2016\n\n\nTreister, E, Haber, E: \nFull waveform inversion guided by travel time tomography\n, arXiv:1607.00968 [cs.CE] 2016", 
            "title": "About"
        }, 
        {
            "location": "/About/#about-jinv", 
            "text": "This page collects contributors, funding, and outcomes of the jInv project. Please create a pull-request if you actively contribute to jInv or show your support when using jInv in your research.", 
            "title": "About jInv"
        }, 
        {
            "location": "/About/#contributors-in-alphabetical-order", 
            "text": "Patrick Belliveau (University of British Columbia)  Eldad Haber (University of British Columbia)  Lars Ruthotto (Emory University)  Eran Treister (Ben Gurion University)  Samy Wu Fung (Emory University)", 
            "title": "Contributors (in alphabetical order)"
        }, 
        {
            "location": "/About/#acknowledgements", 
            "text": "This material is in part based upon work supported by the National Science Foundation under Grant Number 1522599. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/About/#publications-using-jinv", 
            "text": "Ruthotto L, Treister E, Haber E:  jInv - a flexible Julia package for PDE parameter estimation , arXiv:1606.0739 [cs.MS] 2016  Treister, E, Haber, E:  Full waveform inversion guided by travel time tomography , arXiv:1607.00968 [cs.CE] 2016", 
            "title": "Publications using jInv"
        }
    ]
}